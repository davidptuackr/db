05 데이터베이스 프로그래밍



데이터베이스 프로그래밍 방법
    1. SQL 전용 언어 
        mysql: 저장 프로그램, 오라클: PL/SQL, sql server: T-SQL
        다루긴 쉬워도 그래픽 작업이 필요한 경우 한계 봉착
            >>> 프로시저, 함수 등으로 만들어 호출하는 식으로 사용
    2. 프로그래밍 언어에 SQL 삽입
        언어에 쓴 SQL문을 적절히 처리해 DBMS에 전달하는 방식
        SQL 단독 사용보다 다채로운 작업 가능
    3. 웹 프로그래밍 언어에 SQL 삽입
        웹 프로그래밍 언어로 작성된 프로그램에서 데이터 관리, 검색
        결과는 브라우저 상에서 확인
    4. 4GL
        delphi, VB



저장 프로그램
    
    DB 응용 프로그램을 작성하는데 사용하는 mysql의 SQL 전용 언어 *** SQL 전용 언어: SQL + 변수, 제어, 입출력 등)
    프로시저로 구현, 객체 형태로 사용
    DBMS 안에 저장되기 때문에 저장 프로그램이라 하는 것
    구성
        저장 루틴 >>> 프로시저, 함수
        트리거
        이벤트

프로시저 정의 방법
delimiter // (임시로만 변경)
CREATE PROCEDURE 이름(
    매개변수
)
BEGIN
    변수 선언, 초기화
    기타 작업 ...
END
//
delimiter ;
>>> 프로그래밍 언어에서 반환 자료형 선언 대신 CREATE PR..., 시그니처 + 바디, 바디 괄호는 BEGIN, END로 바꾼 형태

프로시저 사용: CALL 프로시저(인자);
프로시저 삭제: DROP PROCEDURE 프로시저;

작성예시
-- 프로시저 InsertBook 정의: ID, 테이블 book에 인자로 받은 책이름, 출판사, 가격을 값으로 하는 튜플을 삽입하는 프로시저
delimiter //
CREATE PROCEDURE InsertBook (
    myBookID INT,
    myBookName VARCHAR(40),
    myPublisher VARCHAR(40),
    myPrice INT
)
BEGIN
    INSERT INTO Book(bookid, bookname, publisher, price)
    VALUES(myBookID, myBookName, myPublisher, myPrice);
END
//
delimiter ;

-- 프로시저 호출
CALL InsertBook(13, 'SPORTS_SCIENCE', 'MADANG', 25000);
SELECT * FROM book;



저장 프로그램의 제어문

    DELIMITER: 구문 종료 기호 설정
    BEGIN-END: ~ 메소드 바디에서 중괄호. 중첩 가능
    IF-ELSE
        IF cond THEN ...
        ELSE ...
        END IF;
    LOOP
        LEAVE를 만나기 전까지 반복
        [label: ] LOOP
        ...
        LEAVE [label: ]
        END LOOP
    WHILE
        조건이 참일 동안 WHILE 블록을 반복
        WHILE cond DO
        ..., [ BREAK / CONTINUE ]
        END WHILE
    REPEAT
        조건이 참일 동안 REPEAT의 블록을 반복
        [label: ] REPEAT
        ... [ BREAK / CONTINUE ]
        UNTIL cond
        END REPEAT [label: ]
    RETURN: 프로시저 종료 + 값 반환

ex. 인자로 받은 책이름이 이미 book에 있다면 가격만 수정하고, 아니면 튜플 삽입
delimiter //
CREATE PROCEDURE book_insert_or_update(
    my_bookid INT,
    my_bookname VARCHAR(40),
    my_pub VARCHAR(40),
    my_price INT
)
BEGIN
    DECLARE cnt INT;
    SELECT COUNT(*) INTO cnt FROM book WHERE bookname LIKE my_bookname;
    IF cnt != 0 THEN
        SET SQL_SAFE_UPDATES = 0;
        UPDATE book SET price = my_price WHERE bookname LIKE my_bookname;
    ELSE
        INSERT INTO book
        VALUES(my_bookid, my_bookname, my_pub, my_price);
    END IF;
END;
//
delimiter ;
CALL book_insert_or_update(15, 'FUN_SPORTS', 'MADANG', 25000);
SELECT * FROM book;
CALL book_insert_or_update(15, 'FUN_SPORTS', 'MADANG', 999999);
SELECT * FROM book;

ex. 도서가격 평균 산출
delimiter //
CREATE PROCEDURE mean_price(
    OUT mean INT
)
BEGIN
    SELECT AVG(price) INTO mean FROM book WHERE price IS NOT NULL;
END;
//
delimiter ;
CALL mean_price(@my_mean);
SELECT @my_mean;

*** 위 프로시저를 좀 더 정확히 이야기하자면
    1. 인자 중 하나는 앞에 OUT을 붙여 결과를 담을 변수로 지정할 것
    2. CALL할 때 프로시저(@변수 이름)과 같이 호출하고
    3. 결과를 보려면 SELECT @변수 이름 과 같이 작성한다



커서
    프로시저의 SQL문 실행 결과가 다중행일 때 각 행을 순서대로 가리키기 위한 것
    
키워드
    CURSOR 커서이름 IS 커서 정의
        커서 생성
        ex1. 출판사가 'orelly'인 도서의 정보를 담은 커서 생성
            DECLARE orelly CURSOR FOR
                SELECT *
                FROM book
                WHERE publisher = 'orelly';
            
    OPEN 커서: 커서 사용 시작
    FETCH 커서 INTO 변수: 행 데이터를 가져옴
    CLOSE 커서: 커서 사용 종료


delimiter //
CREATE PROCEDURE interest()
BEGIN
    DECLARE my_interest INT DEFAULT 0;
    DECLARE price INT;
    DECLARE eor BOOLEAN DEFAULT FALSE;
    DECLARE interest_cursor CURSOR FOR
        SELECT saleprice FROM orders;
    DECLARE CONTINUE handler FOR
        NOT FOUND SET eor=TRUE;
    OPEN interest_cursor;
    cursor_loop: LOOP
        FETCH interest_cursor INTO price;
        IF eor THEN LEAVE cursor_loop;
        END IF;
        IF PRICE >= 30000 THEN SET my_interest = my_interest + price * 0.1;
        ELSE SET my_interest = my_interest + price * 0.05;
        END IF;
    END LOOP cursor_loop;
    CLOSE interest_cursor;
    SELECT CONCAT('NET_INCOME(ET): ', my_interest) net_income;
END;
//
delimiter ;
CALL interest();
>>> ~ while cursor has next do something

*** eor를 바꾸는 부분이 없는데 어떻게 LOOP를 빠져나오는 것인가?
    DECLARE CONTINUE handler FOR NOT FOUND SET eor=TRUE 때문 >>> ~ try - catch
    정확히 말하자면
    DECLARE [ 동작 ] 이름 FOR [ 캐치할 상황 ] 구문 ...
        동작
            CONTINUE: 블록 계속 실행
            EXIT: 블록에서 남은 부분까지만 실행하고 종료
            
        캐치할 상황
            NOT FOUND: 커서가 마지막까지 가서 불러올 데이터가 없을 경우, ==SQLSTATE '02'
            특정 에러 코드: ~1044, ..., 숫자
            SQLSTATE: 5자리 문자열
            SQLWARNING: 경고 (에러가 아님. ~ FutureWarning in python), ==SQLSTATE '01'
            SQLEXCEPTION: SQLSTATE '00', '01', '02' 외 모든 경우
    


트리거
    데이터 변경 (insert, update, delete) 발생 시 자동으로 같이 실행되는 프로시저
    트리거 발생 시점은 변경 전, 변경 대신, 변경 후에 동작하도록 할 수 있다
    ex. 
        변경 전 특정 데이터 저장 >>> 백업
        변경 대신 다른 동작을 하도록 지정
        변동사항 기록 >>> 로깅
    활용: 기본값 제공 (ex. null일 경우 0으로 처리, ...), 제약 준수 (ex. 나이를 소수로 입력하면 알아서 수정), ...
    
ex. book에 새 튜플이 생성될 때마다 book_log에도 이를 알아서 기록하는 트리거 작성
delimiter //
CREATE TRIGGER after_insert_book 
    AFTER INSERT ON book FOR EACH ROW
BEGIN
    DECLARE mean INT;
    INSERT INTO book_log VALUES(new.bookid, new.bookname, new.publisher, new.price);
END;
//
delimiter ;

INSERT INTO book VALUES(14, 'SPORTS_SCIENCE(CH01)', '이상미디어', 25000);
SELECT * FROM book WHERE bookid=14;
SELECT * FROM book_log WHERE bookid_l = 14;



사용자 정의 함수

내장 함수처럼 SQL문과 같이 섞어서 쓸 수 있게 정의하는 함수
    >>> 프로시저는 CALL ~~~ 형태로 사용하지만 사용자 정의 함수는 SELECT func(...)과 같이 사용한다는 점이 차이

스칼라 반환 가능

ex. 각 도서의 이윤을 계산하는 함수 정의
delimiter //
CREATE FUNCTION get_interest (
    price INT ) RETURNS INT
BEGIN
    DECLARE interest INT;
    IF price >= 30000 THEN SET interest = PRICE * 0.1;
    ELSE SET interest = PRICE * 0.05;
    END IF;
    RETURN interest;
END;
//
delimiter ;

SELECT custid, orderid, saleprice, get_interest(saleprice) interest
FROM orders;

결과
    스칼라 값을 반환하는 함수이므로 각 도서 별 이윤을 계산함
    CREATE FUNCTION에서 괄호가 끝나는 지점에 반환형 지정 >>> 정수값을 반환하므로 RETURNS INT
    BEGIN-END 바디 마지막에 반환하는 값 명시
        >>> 여기선 도서 별 이윤을 계산해 interest에 저장하고, 이를 반환



*** 함수 정의가 안될 때
    >>> root 계정에서 SET GLOBAL log_bin_trust_function_creators = ON; 한 다음에 가능

delimiter //

CREATE FUNCTION tst_01(
    tst_var INT) RETURNS INT
BEGIN
    DECLARE tst_rsult INT;
    SET tst_rsult = tst_var * 10;
    RETURN tst_rsult;
END;
//
delimiter ;



DB + java

시작 전 F12 >>> project settings.libraries >>> mysql-connector-java-... .jar 추가

*** 자바로 처리할때도 db의 인덱스는 1로 시작하는 것이 적용된다
ex.
    for (int i = 1; i < mtd.getColumnCount(); i++) { ... } 에서 int i=0으로 하면 SQLException
    >>> 내부에서 자바가 처리할 수 있게 알아서 -1씩 감소시켜준다

코드 분석

Class.forName("com.mysql.cj.jdbc.Driver");
    프로젝트 내 라이브러리에서 "com.mysql.cj.jdbc"로 가서 "Driver"를 찾아낸 뒤 
    실행 중 위 코드를 만나면 그 때 가서 Driver를 로드하도록 한다
    +++
    이 때 드라이버 내의 정적 초기화에 의해 (즉 로드 즉시 실행되도록 짠 코드에 의해)
    드라이버를 드라이버 매니저에 등록하게 된다
    

con = DriverManager.getConnection(url, userid, pwd);


    






















