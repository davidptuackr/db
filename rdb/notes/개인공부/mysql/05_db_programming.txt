05 데이터베이스 프로그래밍



데이터베이스 프로그래밍 방법
    1. SQL 전용 언어 
        mysql: 저장 프로그램, 오라클: PL/SQL, sql server: T-SQL
        다루긴 쉬워도 그래픽 작업이 필요한 경우 한계 봉착
            >>> 프로시저, 함수 등으로 만들어 호출하는 식으로 사용
    2. 프로그래밍 언어에 SQL 삽입
        언어에 쓴 SQL문을 적절히 처리해 DBMS에 전달하는 방식
        SQL 단독 사용보다 다채로운 작업 가능
    3. 웹 프로그래밍 언어에 SQL 삽입
        웹 프로그래밍 언어로 작성된 프로그램에서 데이터 관리, 검색
        결과는 브라우저 상에서 확인
    4. 4GL
        delphi, VB



저장 프로그램
    
    DB 응용 프로그램을 작성하는데 사용하는 mysql의 SQL 전용 언어 *** SQL 전용 언어: SQL + 변수, 제어, 입출력 등)
    프로시저로 구현, 객체 형태로 사용
    DBMS 안에 저장되기 때문에 저장 프로그램이라 하는 것
    구성
        저장 루틴 >>> 프로시저, 함수
        트리거
        이벤트

프로시저 정의 방법
delimiter // (임시로만 변경)
CREATE PROCEDURE 이름(
    매개변수
)
BEGIN
    변수 선언, 초기화
    기타 작업 ...
END
//
delimiter ;

프로시저 사용: CALL 프로시저(인자);
프로시저 삭제: DROP PROCEDURE 프로시저;







delimiter //
CREATE PROCEDURE InsertBook (
    myBookID INT,
    myBookName VARCHAR(40),
    myPublisher VARCHAR(40),
    myPrice INT
)
BEGIN
    INSERT INTO Book(bookid, bookname, publisher, price)
    VALUES(myBookID, myBookName, myPublisher, myPrice);
END
//
delimiter ;

CALL InsertBook(13, 'SPORTS_SCIENCE', 'MADANG', 25000);
SELECT * FROM book;



delimiter //
CREATE PROCEDURE book_insert_or_update(
    my_bookid INT,
    my_bookname VARCHAR(40),
    my_pub VARCHAR(40),
    my_price INT
)
BEGIN
    DECLARE cnt INT;
    SELECT COUNT(*) INTO cnt FROM book WHERE bookname LIKE my_bookname;
    IF cnt != 0 THEN
        SET SQL_SAFE_UPDATES = 0;
        UPDATE book SET price = my_price WHERE bookname LIKE my_bookname;
    ELSE
        INSERT INTO book
        VALUES(my_bookid, my_bookname, my_pub, my_price);
    END IF;
END;
//
delimiter ;

CALL book_insert_or_update(15, 'FUN_SPORTS', 'MADANG', 25000);
SELECT * FROM book;

CALL book_insert_or_update(15, 'FUN_SPORTS', 'MADANG', 999999);
SELECT * FROM book;



delimiter //
CREATE PROCEDURE mean_price(
    OUT mean INT
)
BEGIN
    SELECT AVG(price) INTO mean FROM book WHERE price IS NOT NULL;
END;
//
delimiter ;

CALL mean_price(@my_mean);
SELECT @my_mean;



delimiter //
CREATE PROCEDURE interest()
BEGIN
    DECLARE my_interest INT DEFAULT 0;
    DECLARE price INT;
    DECLARE eor BOOLEAN DEFAULT FALSE;
    DECLARE interest_cursor CURSOR FOR
        SELECT saleprice FROM orders;
    DECLARE CONTINUE handler FOR
        NOT FOUND SET eor=TRUE;
    OPEN interest_cursor;
    cursor_loop: LOOP
        FETCH interest_cursor INTO price;
        IF eor THEN LEAVE cursor_loop;
        END IF;
        IF PRICE >= 30000 THEN SET my_interest = my_interest + price * 0.1;
        ELSE SET my_interest = my_interest + price * 0.05;
        END IF;
    END LOOP cursor_loop;
    CLOSE interest_cursor;
    SELECT CONCAT('NET_INCOME(ET): ', my_interest);
END;
//
delimiter ;

CALL interest();



CREATE TABLE book_log (
    bookid_l INT,
    bookname_l VARCHAR(40),
    publisher_l VARCHAR(40),
    price_l INT
);

delimiter //
CREATE TRIGGER after_insert_book 
    AFTER INSERT ON book FOR EACH ROW
BEGIN
    DECLARE mean INT;
    INSERT INTO book_log VALUES(new.bookid, new.bookname, new.publisher, new.price);
END;
//
delimiter ;

INSERT INTO book VALUES(14, 'SPORTS_SCIENCE(CH01)', '이상미디어', 25000);
SELECT * FROM book WHERE bookid=14;
SELECT * FROM book_log WHERE bookid_l = 14;



delimiter //

CREATE FUNCTION get_interest (
    price INT ) RETURNS INT
BEGIN
    DECLARE interest INT;
    IF price >= 30000 THEN SET interest = PRICE * 0.1;
    ELSE SET interest = PRICE * 0.05;
    END IF;
    RETURN interest;
END;
//
delimiter ;

SELECT custid, orderid, saleprice, get_interest(saleprice) interest
FROM orders;

SET GLOBAL log_bin_trust_function_creators = OFF;

delimiter //

CREATE FUNCTION tst_01(
    tst_var INT) RETURNS INT
BEGIN
    DECLARE tst_rsult INT;
    SET tst_rsult = tst_var * 10;
    RETURN tst_rsult;
END;
//
delimiter ;



