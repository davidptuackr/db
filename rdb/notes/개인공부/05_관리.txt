트랜잭션

    정의: 작업 하나를 수행하는데 필요한 DB의 연산들을 모아놓은 것
    DB의 논리적인 작업 단위
    장애 발생 시 데이터를 복구하는 작업의 단위
    ~ SQL 모임
    
    ex. 계좌이체: A가 B로 5000만큼 송금할 경우 트랜잭션
        1. A의 잔고를 -5000하는 작업
        2. B의 잔고를 +5000하는 작업
        >>> 트랜잭션: 1 + 2
    
    트랜잭션 실행 전후 모두 일관성이 유지돼야 한다.
    
    ACID
        트랜잭션이 성공적으로 처리되어 DB의 무결성과 일관성을 보장하도록 하기 위한 특성
        
        원자성: Atomicity
            트랜잭션을 구성하는 연산들은 모두 정상 수행되거나 하나도 실행되지 않아야 한다.
                >>> 장애 발생으로 다 못했으면 전부 취소 + DB 원상 복구
                >>> 트랜잭션 일부만 반영 불가
            ex. 위의 계좌이체의 경우
                송금을 할거면 A의 잔액 감소, B의 잔액 증가가 다 돼야 함
                한 쪽만 잔액이 바뀌면 실행 전으로 되돌려야 한다.
            
        일관성: Consistency
            트랜잭션이 성공적으로 수행된 후에도 DB가 일관된 상태를 유지해야 한다
            즉, 트랜잭션 실행 전후 모두 일관된 상태여야 한다. (단, 실행 중엔 잠시 일관되지 않을 수 있음)
            ex. 계좌이체의 경우
                이체한 금액이 반영되지 않는 경우(돈이 날라가버리면) 안된다.
                
        격리성 / 고립성: Isolation
            각 트랜잭션이 서로 중간에 끼어들지 못하게 한다 >>> 안그러면 모순 발생 + 일관성 훼손
            이 때문에 실제론 하나씩 빠르게 해서 동시에 처리되는 것처럼 한다.
            ex.
                계좌 이체 트랜잭션 수행 중
                누가 CD기로 현금 2000을 넣은 것을 반영했다면 잔액은 2000? 5000? 7000?
            
        지속성 / 영속성: Durability
            트랜잭션의 성공적인 수행 후 DB에 반영한 결과는 절대 손실되면 안된다.
            즉, 장애 발생 시에도 수행 결과가 DB에 남아 있어야 한다 >>> 장애 회복
            ex.
                시스템 장애(ex, 화재)로 잔고가 0이 되면 큰일난다.
            
        ACID와 관련된 DB의 특성
            원자성, 지속성 >>> 회복
            일관성, 격리성 >>> 병행 제어

    트랜잭션의 연산
        commit: 트랜잭션 수행 성공 + DB에 결과 반영
        rollback: 트랜잭션 수행 실패 >>> 지금까지 했던 연산 취소 + 수행 전으로 복귀

    트랜잭션의 상태 구분
        활동: 아직 수행 중. 이후 부분 완료 or 실패
        부분 완료: 수행은 완료. 아직 commit 받기 전 ( = 결과 반영 전) >>> 이후 완료 / 실패
        완료: commit. 결과 반영 및 트랜잭션 종료 >>> DB가 새로운 일관된 상태
        실패: 트랜잭션 중단 >>> 더이상 정상적인 수행이 안되는 상태
        철회: rollback. 지금까지 했던 연산 모두 취소 + 수행 전으로 복귀 + 트랜잭션 종료 >>> 처음부터 다시 하거나 폐기



장애와 회복
    장애: 시스템이 제대로 동작하지 않는 상태
    회복: 장애 발생 시 DB를 장애 발생 전의 일관된 상태로 복구하는 것

    유형
        트랜잭션 장애
            트랜잭션 수행 중 오류가 발생한 경우
            원인: 트랜잭션의 논리적 오류, 잘못된 데이터 입력, 과도한 자원 요구, 처리 대상 부재 등
            ex. 잔고 이상으로 송금, 송금 액수에 "천원" 입력, div/0 등
        
        시스템 장애: HW 결함, 메모리 상의 정보 손실, 교착 상태 등
        미디어 장애: 디스크 손상, 고장 등 >>> DB 손상

    DB의 저장 연산
        저장 장치 별 특징
            휘발성: 장애 발생 시 데이터 손실
            비휘발성: 미디어 장애 시 데이터 손실
            *** 안정 저장 장치: 비휘발성 저장 장치 복사본. 손실 없이 영구 저장 가능
            
        디스크 - 메모리 간 데이터 이동은 블록 단위로 수행
        
        데이터 이동 연산
            input 디스크 블록 >>> 버퍼 블록 (=메모리 블록)
            output: 버퍼 >>> 디스크
            read: 버퍼 >>> 프로그램 변수
            write: 프로그램 변수 >>> 버퍼

        저장장치 관점의 트랜잭션 처리 과정
            1. 특정 디스크 블록의 데이터 요청
            2. 버퍼 블록에 데이터 적재 >>> input()
            3. 데이터를 처리할 프로그램으로 이동 >>> read()
            4. 처리
            5. 처리 결과를 버퍼 블록에 기록 >>> write()
            6. 디스크 블록에 저장 >>> output()
        
        ex. 계좌이체
            1. 계좌이체 메뉴로 이동
            2. 송금 측의 잔고를 디스크 블록에서 읽어와 버퍼 블록에 적재: input(송금측 잔고)
            3. 은행 프로그램이 디스크 블록에서 잔고를 읽어옴: read(송금측 잔고)
            4. 은행 프로그램이 현재 금액 표시
            5. 송금 액수 입력, 확인
            6. 현재 잔고에서 송금 액수만큼 차감한 금액을 버퍼 블록에 저장: write(송금 후 잔고)
            7. 버퍼 블록의 잔고를 디스크 블록에 저장(송금 후 잔고)
            8. 수신 측도 위와 유사하게 실행
            
        아니면 이렇게?
            1. 보내는 측만 읽어와 버퍼 블록에 저장
            2. 프로그램으로 불러와 이체 가능 금액 표시
            3. 받는 측, 이체 금액 입력
            4. 확인
            5. 금액 차감
            6. 받는 측에 대한 정보를 메모리 블록에 적재
            7. 받는 측의 정보를 프로그램으로 읽어옴
            8. 받는 측 잔고 증가
            9. 메모리 >>> 디스크 순으로 이동
        
    회복
        회복은 DBMS의 회복 관리자가 담당
        미리 저장해둔 복사본을 이용해 이전 상태로 복구
        
        저장 방법
            덤프: DB 전체를 복사
            로그
                변경 연산이 실행될 때마다 before / after 기록
                레코드 단위로 기록 ( ~ 구조체)
                로그 파일 구성
                    <T, start>: 트랜잭션 시작
                    <T, X, old_value, new_value>: T가 데이터 X를 이전 값에서 새로운 값으로 변경
                    <T, commit>: T 성공
                    <T, abort>: T 철회

        복원 방법
            redo
                가장 최근에 저장한 DB 복사본을 불러온 뒤, 복사본 생성 시점 이후에 했던 연산들을 다시 하는 방식
                전반적으로 손상된 경우 주로 사용
            
            undo
                연산했던 것을 취소한 뒤 로그에 있는 변경 전 값으로 되돌리는 방식
                변경 중이었거나 이미 변경된 내용만 신뢰성을 잃은 경우 주로 사용
        
        기법 상세
            로그 회복 기법
                즉시 갱신 회복
                    로그 파일에 기록된 내용을 참조하여 장애 발생 시점에 따라 복구 연산 실행
                        redo: 트랜잭션 완료 후에 장애 발생 시 >>> T, start & T, commit이 모두 있을 때
                        undo: 트랜잭션 완료 전에 장애 발생 시 >>> T, start는 있지만 T, commit이 없는 경우
                        
                    undo, redo가 모두 필요한 경우 undo 먼저 수행
                    redo가 여러번 필요한 경우  먼저 기록된 순서대로 redo 수행
                    
                    ex. 
                        이체가 여러번 있을 때 회복 작업
                            1. 실행 중 장애가 발생한 트랜잭션은 undo + redo
                            2. 나머진 먼저 기록된 순서대로 redo 수행
                                맨 처음 계좌 잔액을 이체 후 금액으로 설정
                                그 다음 계좌 잔액도 이체 후 금액으로 설정
                                ...
                                장애가 발생한 트랜잭션 전까지 실행
                
                지연 갱신 회복
                    DB 연산 결과를 즉시 반영하지 않고 로그에 먼저 기록한 뒤, 부분 완료된 후에 로그 내용을 DB에 반영하는 방식
                        >>> undo 필요 없음. 실행 중 장애가 생기면 해당 로그를 버리고 트랜잭션 한 번 더 실행
                        >>> 트랜잭션 완료 후 장애가 생기면 redo
                
            검사 시점 회복 기법
                일정 시간 간격으로 검사 시점을 만드는 방식. ~ 세이브 포인트
                상세
                    1. 일정 시간 간격으로 메모리에 있는  로그를 한번에 기록하고 실행 결과도 DB에 반영
                    2. 로그 파일에 검사 시점 <checkpoint L> 저장
                        (L: 현재 실행되고 있는 트랜잭션 리스트 >>> L 전까지는 검사 결과 이상 없음)
                    3. 장애 발생 시 가장 최근의 L을 찾아 그 작업에 대해서만 회복
                    4. 즉시 갱신 / 지연 갱신 회복 이용
                
            미디어 회복 기법: 디스크 장애에 대비한 회복. 덤프한 자료로 redo 수행



병행 제어 (= 동시성 제어)

    동시 접근 시에도 문제 없이 정확한 수행 결과를 얻을 수 있도록 트랜잭션 수행을 제어하는 것
    
    병행 수행 시 발생 가능한 문제
        1. 갱신 분실
            변경 연산 결과를 다른 트랜잭션이 덮어쓰면서 변경이 무효화되는 경우
            >>> 특히 중간에 다른 트랜잭션이 개입할 때 
            ex.
                1. T1는 CD기를 이용해 A의 잔고 5000에서 1000만큼 출금
                2. T1 실행 중 T2가 A의 잔고에 2000만큼 입금 (아직 잔고는 5000)
                3. T2 실행 중 T1 완료: 잔고 4000
                4. T2 완료: 잔고는 7000? 4000?
            
        2. 모순성
            일관성 없는 상태의 DB에서 데이터를 가져와 연산을 실행함으로써 모순된 결과가 발생할 경우
            >>> 아직 안끝났는데 가져가 쓰는 경우
            ex.
                1. T1는 계좌 A1에서 계좌 A2(잔고: 2000)로 1000 송금. 
                2. A1의 잔고 -1000
                3. 이 때, T2가 A2의 잔고에서 2000 출금
                4. T1보다 T2가 먼저 완료 >>> 이 때 A2의 잔고: 0
                5. T1 완료 >>> A2 잔고: 1000?, 3000?
                
        *** 1, 2 모두 중간에 다른 트랜잭션이 개입해서 문제 발생

        3. 연쇄 복귀
            상세
                1. T1이 CD기로 잔고가 2000인 A에 +3000 입금
                2. T2가 A에 +2000 입금
                3. T2 먼저 완료
                4. T1 실행 중 장애 발생: rollback 시도
                5. 그럼 T2는? >>> rollback 불가
            
        해결: 먼저 온 트랜잭션 먼저 수행. 끝나면 그 다음에 온 것 실행 >>> 순차적으로
            
    트랜잭션 스케줄
        직렬 스케줄: 한 번에 하나씩만 작업. >>> 정확하지만 병행 수행 불가
        비직렬 스케줄: 트랜잭션을 번갈아가면서 수행 (인터리빙) >>> 정확할 수도, 아닐 수도 있음
        직렬 가능 스케줄: 결과가 직렬 스케줄과 같은 비직렬 스케줄 >>> 병행 제어로 직렬 가능 보장
        
    병행 제어
        특정 규칙에 맞춰 병렬 수행하는 것
        >>> 직렬 가능성 보장. 즉, 규칙만 잘 따른다면 직렬 가능성을 검사할 필요 없음
            
        로킹 기법
            같은 데이터에 동시에 접근하지 못하도록 상호 배제하는 법
            먼저 온 트랜잭션이 끝나기 전까진 다른 이들이 접근 불가
            로킹 연산
                lock: 트랜잭션이 데이터에 대한 독점권 획득
                unlock: 독점권 반납
                
            로킹 규약
                1. 데이터 접근 시 lock 먼저 >>> RW 전 lock
                2. lock한 데이터에는 다른 트랜잭션이 또 와서 lock할 수 없음
                3. 다 쓰고 나면 unlock
            
            로킹 단위
                범위: 데이터 < 튜플 < 릴레이션 < DB
                병행성: 데이터 > 튜플 > 릴레이션 > DB
                *** 범위, 병행 정도는 트레이드오프 관계
            
            로킹 기법 상세
                write은 누가 개입해선 안되지만 read는 동시에 많이 해도 무방
                    공용 락: read 가능, write만 불가 + 여러 트랜잭션이 한 대상에 공용 락 가능
                    전용 락: rw 불가 >>> 한 트랜잭션이 독점. 누가 와서 또 lock 할 수 없음
            
            2단계 로킹 규약
                여기까지 해야 직렬 가능성 보장 >>> 단순 로킹만으론 불가능
                상세
                    확장 단계: 트랜잭션이 lock만 가능하고 unlock은 안되는 단계
                    축소 단계: 트랜잭션이 unlock만 가능하고 lock은 안되는 단계
                    
                    *** 처음 트랜잭션 시작 시엔 확장 단계. 이후 특정 시점에 unlock 실행 시 그때부턴 축소
                    
                교착상태까진 해결 불가 (어떤 이유로 데이터를 unlock 못하고 계속 점유할 때)
                
            
                
            

                    
                
        














